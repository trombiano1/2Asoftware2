#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>
#include <string.h>

// ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ¡ä»¶ã‚’æ ¼ç´ã™ã‚‹æ§‹é€ ä½“
// åç™ºä¿‚æ•°CORã‚’è¿½åŠ 
typedef struct condition
{
  const int width; // è¦‹ãˆã¦ã„ã‚‹ç¯„å›²ã®å¹…
  const int height; // è¦‹ãˆã¦ã„ã‚‹ç¯„å›²ã®é«˜ã•
  const double G; // é‡åŠ›å®šæ•°
  const double dt; // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æ™‚é–“å¹…
  const double cor; // å£ã®åç™ºä¿‚æ•°
} Condition;

// å€‹ã€…ã®ç‰©ä½“ã‚’è¡¨ã™æ§‹é€ ä½“
typedef struct object
{
  double m;
  double y;
  double x;
  double prev_y; // å£ã‹ã‚‰ã®åç™ºã«ä½¿ç”¨
  double prev_x;
  double vy;
  double vx;
} Object;

double distance(Object objs[], int m, int n){
  return sqrt((objs[m].x - objs[n].x)*(objs[m].x - objs[n].x)+(objs[m].y - objs[n].y)*(objs[m].y - objs[n].y));
}

void my_plot_objects(Object objs[], const size_t numobj, const double t, const Condition cond){
  FILE *fp = stdout;

  /*information*/
  /* for(size_t i = 0; i < numobj; ++i){ */
  /*   printf("t = \t%f, objs[%zu]: (x,y) = (%f,%f), (vx,vy) = (%f,%f)\n",t,i,objs[i].x,objs[i].y,objs[i].vx,objs[i].vy); */
  /* } */
  /*ä¸Šã®å£*/
  fprintf(fp,"+");
  for (int x = 0 ; x < cond.width ; x++)
    fprintf(fp, "--");
  fprintf(fp, "+\n");

  int print_flag = 0;
  
  /* å¤–å£ã¨ å†…å´ã®ã‚²ãƒ¼ãƒ éƒ¨åˆ† */
  for (int y = 0; y < cond.height; y++) {
    fprintf(fp,"|");
    for (int x = 0; x < cond.width; x++) {
      print_flag = 0;
      // ANSIã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚³ãƒ¼ãƒ‰ã‚’ç”¨ã„ã¦ã€èµ¤ã„"#" ã‚’è¡¨ç¤º
      // \e[31m ã§ èµ¤è‰²ã«å¤‰æ›´
      // \e[0m ã§ãƒªã‚»ãƒƒãƒˆï¼ˆãƒªã‚»ãƒƒãƒˆã—ãªã„ã¨ä»¥é™ã‚‚èµ¤ããªã‚‹ï¼‰
      for(size_t i = 0; i < numobj; ++i){
	if((int)objs[i].y+(cond.height/2) == y && (int)objs[i].x+(cond.width/2) == x){ 
	  print_flag = 1;
	}
      }
      if(print_flag){
	fprintf(fp, "ğŸ¥º");
      }else{ 
	fprintf(fp, "  ");
      }
    }
    fprintf(fp,"|\n");
  }

  /*ä¸‹ã®å£*/
  fprintf(fp, "+");
  for (int x = 0 ; x < cond.width ; x++)
    fprintf(fp, "--");
  fprintf(fp, "+\n");
  
  fflush(fp);
}

void my_update_velocities(Object objs[], const size_t numobj, const Condition cond){
  double a_y;
  double a_x;
  for(size_t i = 0; i < numobj; ++i){
    a_y = 0.0;
    a_x = 0.0;
    for(size_t j = 0; j < numobj; ++j){
      if(i != j){
	a_x += (cond.G * (objs[j].m) / (pow(distance(objs, i, j),3)))*(objs[j].x-objs[i].x);
	a_y += (cond.G * (objs[j].m) / (pow(distance(objs, i, j),3)))*(objs[j].y-objs[i].y);
      }
    }
    objs[i].vy += a_y * cond.dt;
    objs[i].vx += a_x * cond.dt;
  }
}

void my_update_positions(Object objs[], const size_t numobj, const Condition cond){
  for(size_t i = 0; i < numobj; ++i){
    objs[i].prev_y = objs[i].y;
    objs[i].y += objs[i].vy * cond.dt;
    objs[i].prev_x = objs[i].x;
    objs[i].x += objs[i].vx * cond.dt;
  }
}

void my_bounce(Object objs[], const size_t numobj, const Condition cond){
  for(size_t i = 0; i < numobj; ++i){
    if((cond.height / 2 > objs[i].prev_y) && (objs[i].y > cond.height / 2)){ //ä¸‹ã®å£
      objs[i].vy = -1 * objs[i].vy * cond.cor;
      objs[i].y = -1 * (objs[i].y - cond.height/2) + cond.height/2;
    }
    if((-1 * cond.height / 2 < objs[i].prev_y) && (objs[i].y < -1 * cond.height / 2)){ //ä¸Šã®å£
      objs[i].vy = -1 * objs[i].vy * cond.cor;
      objs[i].y = (-1 * cond.height/2 - objs[i].y) - cond.height/2;
    }
    if((cond.width / 2 > objs[i].prev_x) && (objs[i].x > cond.width / 2)){ //ä¸‹ã®å£
      objs[i].vx = -1 * objs[i].vx * cond.cor;
      objs[i].x = -1 * (objs[i].x - cond.width/2) + cond.width/2;
    }
    if((-1 * cond.width / 2 < objs[i].prev_x) && (objs[i].x < -1 * cond.width / 2)){ //ä¸Šã®å£
      objs[i].vx = -1 * objs[i].vx * cond.cor;
      objs[i].x = (-1 * cond.width/2 - objs[i].x) - cond.width/2;
    }
  }
}

void my_collide(Object objs[], size_t *numobj_p, Condition cond){
  for(size_t i = 0; i < *numobj_p; ++i){
    for(size_t j = 0; j < *numobj_p; ++j){
      if(i != j){
	if(distance(objs,i,j) < 0.2 && objs[j].m != 0.0){
	  objs[i].vx = (objs[i].m * objs[i].vx + objs[j].m * objs[j].vx)/(objs[i].m + objs[j].m);
	  objs[i].vy = (objs[i].m * objs[i].vy + objs[j].m * objs[j].vy)/(objs[i].m + objs[j].m);
	  objs[i].m = objs[i].m + objs[j].m;
	  objs[j].m = 0.0;
	  objs[j].x = 10000000000.0;
	}
      }
    }
  }
}

int main(int argc, char **argv)
{
  const Condition cond = {
		    .width  = 50 ,
		    .height = 30,
		    .G = 1.0,
		    .dt = 0.1,
		    .cor = 0.8
  };
  
  size_t objnum = atoi(argv[1]);
  size_t *objnum_p = &objnum;
  Object objects[objnum];

  objects[0] = (Object){ .m = 60.0, .x = 0.0, .y = -19.9, .vx = 0.0, .vy = 2.0};
  
  FILE *file;
  char row[100];
  char * token;
  file = fopen(argv[2],"r");
  size_t just_count = 0;
  while(fgets(row, sizeof(row), file) != NULL){
    if(row[0] != '#'){
      if(just_count < objnum){
	token = strtok(row, " ");
	objects[just_count].m = atoi(token);
	token = strtok(NULL, " ");
	objects[just_count].x = atoi(token);
	token = strtok(NULL, " ");
	objects[just_count].y = atoi(token);
	token = strtok(NULL, " ");
	objects[just_count].vx = atoi(token);
	token = strtok(NULL, " ");
	objects[just_count].vy = atoi(token);
	just_count++;
      }
    }
  }
  for(size_t i = just_count; i < objnum; ++i){
    objects[i].m = 0.0;
    objects[i].x = 0.0;
    objects[i].y = 0.0;
    objects[i].vx = 0.0;
    objects[i].vy = 0.0;
    just_count++;
  }
  fclose(file);

  // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³. ãƒ«ãƒ¼ãƒ—ã¯æ•´æ•°ã§å›ã—ã¤ã¤ã€å®Ÿæ•°æ™‚é–“ã‚‚æ›´æ–°ã™ã‚‹
  const double stop_time = 400;
  double t = 0;
  printf("\n");
  for (int i = 0 ; t <= stop_time ; i++){
    t = i * cond.dt;
    my_update_velocities(objects, objnum, cond);
    my_update_positions(objects, objnum, cond);
    my_collide(objects, objnum_p, cond);
    my_bounce(objects, objnum, cond);
    
    // è¡¨ç¤ºã®åº§æ¨™ç³»ã¯ width/2, height/2 ã®ãƒ”ã‚¯ã‚»ãƒ«ä½ç½®ãŒåŸç‚¹ã¨ãªã‚‹ã‚ˆã†ã«ã™ã‚‹
    my_plot_objects(objects, objnum, t, cond);
    usleep(200 * 100); // 200 x 1000us = 200 ms ãšã¤åœæ­¢
    printf("\e[%dA", cond.height+2);// å£ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¡¨ç¤ºåˆ†ã§3è¡Œ
  }
  return EXIT_SUCCESS;
}

// å®Ÿç¿’: ä»¥ä¸‹ã« my_ ã§å§‹ã¾ã‚‹é–¢æ•°ã‚’å®Ÿè£…ã™ã‚‹
// æœ€çµ‚çš„ã« phisics2.h å†…ã®äº‹å‰ã«ç”¨æ„ã•ã‚ŒãŸé–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
